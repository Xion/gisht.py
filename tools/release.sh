#!/bin/sh

# Release automation script

set -e


REQUIREMENTS='poet'
HOMEBREW_FORMULA='gisht.rb'


main() {
    for req in $REQUIREMENTS; do
        require $req "Development packages not installed, aborting."
    done

    ensure_release_version

    create_homebrew_formula
    upload_to_pypi

    add_git_tag
    git_push
}


# Version management

ensure_release_version() {
    local version="$(get_version)"

    # check if the version number is a one that doesn't
    # indicate a valid release, e.g. "0.5-dev" instead of just "0.5"
    if ! matches "$version" "^[0-9]+(\\.[0-9]+)+$" ; then
        fatal "Invalid version number: %s" "$version"
    fi
}

get_version() {
    cat gisht/__init__.py | \
    sed -E -n "/__version__ = [\"'](.+)[\"']/s//\1/p"
}

# Package management

create_homebrew_formula() {
    log "Creating Homebrew formula..."

    local tmpfile="/tmp/$HOMEBREW_FORMULA"
    rm -f "$tmpfile"

    # generate the formula using homebrew-pypi-poet
    cat << EOF >"$tmpfile"
# gisht :: Homebrew formula definition
# AUTOGENERATED BY ./tools/release.sh -- DO NOT EDIT!

EOF
    poet --formula gisht >>"$tmpfile"

    # commit it if it's got any changes
    if different "$tmpfile" "./$HOMEBREW_FORMULA" ; then
        mv -f "$tmpfile" "./$HOMEBREW_FORMULA"

        log "Formula created, committing..."

        # TODO(xion): include version in the commit
        git add "./$HOMEBREW_FORMULA"
        if git commit --edit --message="Regenerate Homebrew formula" ; then
            log "New Homebrew formula generated & committed."
        else
            log "Aborted at committing Homebrew formula"
            exit 1
        fi
    else
        log "Formula already up to date."
    fi
}

upload_to_pypi() {
    local version="$(get_version)"
    log "Uploading version $version to PyPI..."

    local pypi_out="$(python setup.py sdist upload 2>&1)"
    if matches "$pypi_out" 'Upload failed' ; then
        echo 1>&2 "$pypi_out"
        fatal "Failed to upload version $version to PyPI"
    fi

    log "PyPI upload complete."
}


# Git

add_git_tag() {
    local version="$(get_version)"

    # TODO(xion): overwrite previous tag, if any
    if ! git tag "$version"; then
        fatal "Failed to add Git tag for version %s" "$version"
    fi
}

git_push() {
    # TODO(xion): remove previously exisiting tag on the remote, if any
    if ! git push && git push --tags ; then
        fatal "Failed to push the release upstream"
    fi
}


# Utility functions

require() {
    # Require for an external program to exist, abort the script if not found
    local prog="$1"
    local msg="${2-$prog not found, aborting.}"
    which "$prog" >/dev/null || fatal "$msg"
}

different() {
    # Compare two files and return 0 if they differ.
    local f1="$1"
    local f2="$2"

    if [ ! -f "$f1" ] && [ ! -f "$f2" ]; then
        return 1
    fi

    if [ -f "$f1" ] && [ ! -f "$f2" ]; then
        return 0
    fi
    if [ ! -f "$f1" ] && [ -f "$f2" ]; then
        return 0
    fi

    cmp "$f1" "$f2" 2>&1 >/dev/null && return 1 || return 0
}

matches() {
    # Check if given string matches a(n extended) regular expression.
    local s="$1"
    local re="$2"
    echo "$s" | grep -E "$2" >/dev/null
}

fatal() {
    local fmt="$1" ; shift
    log "FATAL: $fmt" "$@"
    exit 1
}

log() {
    local fmt="$1" ; shift
    printf >&2 ">>> $fmt\n" "$@"
}


main "$@"
